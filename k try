# -*- coding: utf-8 -*-
"""
Created on Mon Jul  1 11:03:45 2019

@author: Uschi
"""

import collections

import itertools

import math

import numpy as np



data = np.genfromtxt("bananas-1-2d.test.csv", delimiter = ",")



def square_distance(a, b):

    s = 0

    for x, y in itertools.izip(a, b):

        d = x - y

        s += d * d

    return s



def d(x,b):

    n = np.size(x)

    s = 0

    for i in np.arange(1,n,1):

        s = s + (x[i] - b[i])**2

    return s



Node = collections.namedtuple("Node", 'point axis left right')



x = [1,0.5,0.5]



class KDTree(object):
    
    def __init__(self, k, destination, objects):



        def build_tree(objects, axis=1):



            if not objects:

                return None



            objects.sort(key=lambda o: o[axis])

            median_idx = len(objects) // 2

            median_point = objects[median_idx]



            next_axis = (((axis + 1) % k) + (axis % 2) * 2)

            return Node(median_point, axis,

                        build_tree(objects[:median_idx], next_axis),

                        build_tree(objects[median_idx + 1:], next_axis))



        self.root = build_tree(list(objects))

        

        def nearest_neighbor(self, destination):



            best = []
            for i in range(k):
                best.append([0,2*k])

            def recursive_search(here):



                if here is None:

                    return

                point, axis, left, right = here

                here_sd = d(point, destination)

                if here_sd < best[k-1][1]:
                    j=int(k/2)
                    u=0
                    o=k-1
                    while j>0:
                        if(here_sd<best[u+j-1][1]):
                            o=o-j
                        else:
                            u=u+j
                        if(o-u==j):
                            j=int(j/2)
                        else:
                            j=int(j/2)+1
                        best[u+1:k] = best[u:k-1]
                        #best[u]=[i,here_sd]

                diff = destination[axis] - point[axis]

                close, away = (left, right) if diff <= 0 else (right, left)



                recursive_search(close)

                if diff ** 2 < best[k-1][1]:

                    recursive_search(away)



            recursive_search(self.root)

            return best[0], math.sqrt(best[1])

        self.nearest_neighbor = nearest_neighbor(self, destination) 

        

        

        

A = KDTree(2,x,data)

print (A.root)

print (A.nearest_neighbor)
